<!DOCTYPE html><html><head><meta charset="utf-8"><title>Coffee Script - Javascript for stressed developers</title><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="stylesheet" href="../lib/revealjs/css/reveal.min.css"><link rel="stylesheet" href="../lib/revealjs/css/theme/beige.css" id="theme"><!-- For syntax highlighting--><link rel="stylesheet" href="../lib/revealjs/css/zenburn.css"><link rel="stylesheet" href="../stylesheets/presentation.css"><!--[if lt IE 9]><script src="../lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><!-- Any section element inside of this container is displayed as a slide--><div class="slides"><section><h1>Coffee Script</h1><h3>Compiled Javascript for stressed developers</h3><p><small>Created by<a href="http://wilky.it">Vincenzo Ferrari</a>/ <a href="http://twitter.com/__wilky__">@__wilky__</a></small></p><img src="../images/coffee.gif" alt="CoffeeScript"></section><section><h2>What are we talking about?</h2><p>#Javascript #CompiledJavascript #ClientServerSide</p><small>Another opportunity to write web apps for who doesn't like Javascript</small></section><section><h2>Why not Javascript?</h2><p>It isn't a bad language (I like it) but:</p><ul><li>it's verbose</li><li>sometimes, it's not so clear</li><li>it hasn't a real class system</li><li>I'm looking for something easier</li></ul></section><section><section><h2>Overview</h2><p>CoffeeScript is a little language that compiles one-to-one into JavaScript and tends to run as fast or faster than the equivalent handwritten JavaScript.</p><p>CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.</p></section><section><h2>Compiler</h2><p>The CoffeeScript compiler is itself written in CoffeeScript, using the Jison parser generator. </p>The command-line version of coffee is available as a Node.js utility.
The core compiler however, does not depend on Node, and can be run in any JavaScript environment, or in the browser.</section></section><section><h2>Installation</h2><p>You can install CoffeeScript with npm:</p><small>$ sudo npm install -g coffee-script</small><p>Or, if you want to install to /usr/local, and don't want to use npm to manage it, open the coffee-script directory and run:</p><small>$ sudo bin/cake install</small></section><section><section><h2>Usage</h2><p>The coffee command can execute scripts, compile .coffee files into .js, and provide an interactive REPL:</p><small>$ coffee</small></section><section><h2>Options</h2><table><tr><td class="command"><small>-c, --compile</small></td><td>Compile a .coffee script into a .js JavaScript file of the same name.</td></tr><tr><td class="command"><small>-m, --map</small></td><td>Generate source maps alongside the compiled JavaScript files. Adds sourceMappingURL directives to the JavaScript as well.</td></tr><tr><td class="command"><small>-o, --output</small></td><td>Write out all compiled JavaScript files into the specified directory. Use in conjunction with --compile or --watch.</td></tr><tr><td class="command"><small>-j, --join</small></td><td>Before compiling, concatenate all scripts together in the order they were passed, and write them into the specified file.</td></tr><tr><td class="command"><small>-w, --watch</small></td><td>Watch files for changes, rerunning the specified command when any file is updated.</td></tr></table></section><section><h2>Examples</h2><table><tr><td class="command"><small>coffee --compile --output lib/ src/</small></td><td>Compile a directory tree of .coffee files in src into a parallel tree of .js files in lib</td></tr><tr><td class="command"><small>coffee --watch --compile experimental.coffee</small></td><td>Watch a file for changes, and recompile it every time the file is saved</td></tr><tr><td class="command"><small>coffee --join project.js --compile src/*.coffee</small></td><td>Concatenate a list of files into a single script</td></tr><tr><td class="command"><small>coffee -o lib/ -cw src/</small></td><td>watch and recompile an entire project as you work on it:</td></tr></table></section></section><section><h2>Language Reference</h2><p>CoffeeScript uses significant whitespace to delimit blocks of code. Instead of using curly braces  { } to surround blocks of code, use indentation.</p>You don't need to use parentheses to invoke a function if you're passing arguments. The implicit call wraps forward to the end of the line or block expression.</section><section><section><h2>Literals</h2><p>CoffeeScript redefines literals, like functions, objects and arrays in a very cool way.</p></section><section><h3>Functions</h3><p>Functions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: -></p>Functions may also have default values for arguments. Override the default value by passing a non-null argument.</section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section><section><h3>Arrays & Objects</h3><p>The CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional.</p>Objects may be created using indentation instead of explicit braces, similar to YAML.</section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><section><h2>Lexical scoping</h2><p>The CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write  var yourself.</p></section><section><h3>Variable safety</h3><p>All CoffeeScript output is wrapped in an anonymous function:  (function(){ ... })(); </p>This safety wrapper, combined with the automatic generation of the var keyword, make it exceedingly difficult to pollute the global namespace by accident. 
If you'd like to create top-level variables for other scripts to use, attach them as properties on window.</section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><section><h2>Conditions</h2><p>If/else statements can be written without the use of parentheses and curly brackets. </p>As with functions and other block expressions, multi-line conditionals are delimited by indentation.
There's also a handy postfix form, with the if or unless at the end.</section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><section><h2>Splats</h2><p>The JavaScript arguments object is a useful way to work with functions that accept variable numbers of arguments.</p>CoffeeScript provides splats ..., both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable.</section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><section><h2>Loops and comprehensions</h2><p>Most of the loops you'll write in CoffeeScript will be comprehensions over arrays, objects, and ranges.</p>Comprehensions replace (and compile into) for loops, with optional guard clauses and the value of the current array index.
Unlike for loops, array comprehensions are expressions, and can be returned and assigned.</section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section><section><h3>Comprehensions tips'n'tricks</h3><ul><li>To step through a range comprehension in fixed-size chunks, use by</li><li>To step over the keys and values of an object, use of</li><li>To step over just the keys that are defined on the object itself, use own</li><li>To step over the values of an array, use in</li></ul></section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section><section><h3>Low-level loops</h3><p>The only low-level loop that CoffeeScript provides is the while loop.</p>The main difference from JavaScript is that the while loop can be used as an expression, returning an array containing the result of each iteration through the loop.
The until keyword is equivalent to while not, and the loop keyword is equivalent to while true.</section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><section><h2>Ranges</h2><p>Ranges can also be used to extract slices of arrays.</p>With two dots (3..6), the range is inclusive (3, 4, 5, 6); with three dots (3...6), the range excludes the end (3, 4, 5).
Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.
The same syntax can be used with assignment to replace a segment of an array with new values, splicing it.</section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><section><h2>Operators and Aliases</h2><table class="aliases"><tr><th>CoffeeScript</th><th>Javascript</th></tr><tr><td>==, is</td><td>===</td></tr><tr><td>!=, isnt</td><td>!==</td></tr><tr><td>not</td><td>!</td></tr><tr><td>and</td><td>&amp;&amp;</td></tr><tr><td>or</td><td>||</td></tr><tr><td>yes, on</td><td>true</td></tr><tr><td>no, off</td><td>false</td></tr><tr><td>@</td><td>this</td></tr><tr><td>of</td><td>in</td></tr></table></section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section><section><h3>The Existential Operator</h3><p>CoffeeScript's existential operator ? returns true unless a variable is null or undefined, which makes it analogous to Ruby's nil?</p>The accessor variant of the existential operator ?. can be used to soak up null references in a chain of properties.</section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><section><h2>Classes</h2><p>CoffeeScript provides a basic class structure that allows you to name your class, set the superclass, assign prototypal properties, and define the constructor, in a single assignable expression.</p>Constructor functions are named, to better support helpful stack traces.
The extends operator helps with proper prototype setup, and can be used to create an inheritance chain between any pair of constructor functions; :: gives you quick access to an object's prototype; and super() is converted into a call against the immediate ancestor's method of the same name.
You can assign static properties by using @property: value, and call functions defined in parent classes.</section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><section><h2>Destructuring Assignment</h2><p>CoffeeScript implements ECMAScript Harmony's proposed destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left.</p></section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section><section><h3>Tips'n'tricks</h3><ul><li>helpful for dealing with functions that return multiple values</li><li>can be used with any depth of array and object nesting, to help pull out deeply nested properties</li><li>can even be combined with splats</li><li>useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor</li></ul></section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><section><h2>Function Binding</h2><p>The fat arrow => can be used to both define a function, and to bind it to the current value of this, right on the spot.</p>Functions created with the fat arrow are able to access properties of the this where they're defined.</section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><section><h2>Embedded JavaScript</h2><p>Hopefully, you'll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.</p></section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><section><h2>Switch/When/Else</h2><p>CoffeeScript prevents accidental fall-through, and can convert the switch into a returnable, assignable expression. The format is: switch condition,  when clauses, else the default case.</p>As in Ruby, switch statements in CoffeeScript can take multiple values for each when clause. If any of the values match, the clause runs.
Switch statements can also be used without a control expression, turning them in to a cleaner alternative to if/else chains.</section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><section><h2>Chained Comparisons</h2><p>CoffeeScript borrows chained comparisons from Python — making it easy to test if a value falls within a certain range.</p></section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><section><h2>String Interpolation, Block Strings and Block Comments</h2><p>Ruby-style string interpolation is included in CoffeeScript. Double-quoted strings allow for interpolated values, using #{ ... }, and single-quoted strings are literal.</p>The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.</section><section><h3>Practice</h3><div class="practice"><textarea class="coffee"></textarea><pre class="javascript"></pre></div><div class="debug"></div></section></section><section><h2>Cake & Cakefiles</h2><p>CoffeeScript includes a (very) simple build system similar to Make and Rake. Naturally, it's called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named Cakefile, and can be invoked by running cake [task] from within the directory. To print a list of all the tasks and options, just type cake.</p></section><section><h2>Source Maps</h2><p>CoffeeScript 1.6.1 and above include support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated.</p></section><section><h2>Credits</h2></section></div></div><script src="../lib/jquery/jquery-1.10.2.min.js"></script><script src="../lib/coffeescript/coffee-script.js"></script><script src="../lib/revealjs/js/head.min.js"></script><script src="../lib/revealjs/js/reveal.min.js"></script><script src="../js/init.js"></script><script src="../js/slides.js"></script></body></html>